## Notas de la clase

> La arquitectura de software representa la estructura o estructras del sistema que consiste en componentes de software, las propiedades externas visibles de esos componentes y las relaciones entre ellos.

Componente de software: Código fuente, código binario, un ejecutable, o una biblioteca con una interfaz definida.

El Diagrama de Componentes tiene un nivel de abstracción más alto que un Diagrama de Clases.

Niveles de arquitectura de software (de más general a más específico)
1. Enterprise: Define la estrategia tecnológica y de negocio de la organización para el desarrollo de sus sistemas. Están definidas a nivel empresa.
2. Sistema: Arquitectura de Software e Infraestructura. Refiere al despliegue del sistema.
3. Software: Arquitectura de Software para una aplicación o Subsistema.

Project Manager =/= Arquitecto de Software.

El Frontend de un aplicativo es la parte visual del mismo, la que vería el usuario. Refiere al diseño e implementación de este.

El Backend de un aplicativo contiene toda, o la mayor parte, de la lógica de negocio. Le da sustento al frontend.

Nodo de un Diagrama de Componentes: Representa un componente físico.

Orquestación de un CU: Resolver el CU en cuestión por medio de varias capas a nivel arquitectura.

Los objetos que se quieran persistir se vuelven *objetos repositorios*.

Todo objeto que sale y que entra a un service va a ser un Data Transfer Object (DTO). Suelen ser Value Objects.

### Modelo en capas

Es un patrón de arquitectura donde el sistema se divide en capas, cada capa es un todo coherente con un rol único en el sistema.

Las capas superiores usan servicios de las inferiores, de forma unidireccional.

* Ventajas:
  * Esconde el detalle de cómo se llevan a cabo los servicios que expone.
  * Minimiza la dependencia entre los componentes.
  * Facilita las pruebas.
* Desventajas:
  * Los cambios pueden generar efecto cascada.
  * Demasiadas capas pueden agregar complejidad y afectar negativamente al rendimiento.

| Delegación de las capas |
| :-: |
| Presentación |
| Servicios / Controladores |
| Dominio / Negocio |
| Persistencia / Datos |

Capa de presentación: Se encarga de presentar los datos al usuario. Se puede categorizar en al menos dos formas:
  * Presentación mediante interfaz gráfica. Ej: Interfaz desktop, interfaz Web, aplicación móvil, etc.
  * Presentación mediante APIs. Ej: API REST.

Capa de servicios: Se encarga de orquestar a los casos de uso. Contiene la mayor cantidad de lógica de flujo de un caso de uso.

Capa de controladores: Contiene los métodos que orquestan las funcionalidades, además de verificar si el usuario que realiza una acción tiene los permisos necesarios.

Capa de dominio / negocio: Se encarga de modelar las reglas de negocio, las entidades del dominio. Contiene la parte estructural y de comportamiento que brinda sostén a todos los posibles casos de uso del sistema.

Capa de persistencia / de datos: Se encarga de almacenar todos los repositorios. Los cuales son objetos encargados de la persistencia de otros objetos.

### Modelo-Vista-Controlador (MVC)

Es un patrón de arquitectura que separa al sistema en tres componentes: El modelo, la vista y el controlador.

Modelo: Está vinculado con la representación de los datos con los cuales el sistema opera. Envía a la Vista, a través del Controller, los datos solicitados para que sean visualizados.
* Encapsula el estado del sistema.
* Gestiona todos los acceso a los datos.
* Valida la especificación de la lógica detallada en el "negocio".

Controlador / Controller: Responde a eventos (como acciones del usuario) e invoca peticiones al modelo cuando se hace alguna solicitud sobre los datos. Es intermediario entre el Modelo y la Vista.
* Define el comportamiento del sistema.
* Traduce acciones del usuario a actualizaciones del modelo.
* Es el gestor del ciclo de vida del sistema.

Vista: Presenta los datos y su forma de interactuar en un formato adecuado para el usuario.
* Posee lógica para poder representar los datos de la forma mas "amigable" para el usuario.
* Envia acciones del usuario del usuario al controlador.
* Solicita actualizaciones al modelo a través del controller.
* La comunicación entre la vista y el controlador se realiza mediante DTOs

* Ventajas:
  * Buena separación de intereses.
  * Reusabilidad de Vistas y Controladores.
  * Flexibilidad.
* Desventajas:
  * Mayor complejidad
  * Dificil de testear como un todo